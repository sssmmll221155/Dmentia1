<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Tracker - Live Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="webgazer.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            padding: 20px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            color: #667eea;
            font-size: 28px;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
        }

        .status-badge.active {
            background-color: #10b981;
            color: white;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .card h2 {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 36px;
            font-weight: bold;
            color: #667eea;
        }

        .metric-value small {
            font-size: 14px;
            color: #999;
        }

        #gaze-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .gaze-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #webcam-container {
            position: relative;
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        #webcam-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }

        .button:hover {
            background: #5568d3;
        }

        .button.danger {
            background: #ef4444;
        }

        .button.danger:hover {
            background: #dc2626;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>üß† Cognitive Tracker</h1>
                <p style="color: #666; margin-top: 5px;">Real-Time Behavioral Monitoring</p>
            </div>
            <div>
                <span id="tracking-status" class="status-badge active">Tracking Active</span>
            </div>
        </div>

        <!-- Live Metrics Grid -->
        <div class="grid">
            <div class="card">
                <h2>‚å®Ô∏è Typing Speed</h2>
                <div id="metric-typing-speed" class="metric-value">0 <small>keys/s</small></div>
            </div>

            <div class="card">
                <h2>üñ±Ô∏è Mouse Speed</h2>
                <div id="metric-mouse-speed" class="metric-value">0 <small>px/s</small></div>
            </div>

            <div class="card">
                <h2>‚ùå Error Rate</h2>
                <div id="metric-error-rate" class="metric-value">0%</div>
            </div>

            <div class="card">
                <h2>üì¶ Batches Sent</h2>
                <div id="metric-batches" class="metric-value">0</div>
            </div>
        </div>

        <!-- Eye Tracking Section -->
        <div class="card" style="margin-bottom: 20px;">
            <h2>üëÅÔ∏è Eye Tracking (WebGazer)</h2>
            <div id="webcam-container">
                <video id="webgazerVideoFeed" autoplay playsinline></video>
            </div>
            <div style="margin-top: 15px;">
                <button id="start-gaze" class="button">Start Eye Tracking</button>
                <button id="stop-gaze" class="button danger" style="display: none;">Stop Eye Tracking</button>
                <p style="margin-top: 10px; color: #666; font-size: 14px;">
                    Eye tracking uses your webcam to detect where you're looking on screen.
                    Red dot shows gaze position. Click around to calibrate.
                </p>
            </div>
        </div>

        <!-- Eye Tracking Calibration -->
        <div class="card">
            <h2>üéØ Eye Tracking Calibration</h2>
            <p style="margin-bottom: 10px; color: #666;">
                <strong>Important:</strong> Start eye tracking first, then calibrate.<br>
                Click each red dot 5 times while looking directly at it.
            </p>
            <button id="calibrate-eyes" class="btn">Calibrate Eyes (9 Points)</button>
            <div id="calibration-status" style="margin-top: 10px; color: #667eea; font-weight: 500;"></div>
        </div>
    </div>

    <!-- Gaze overlay -->
    <div id="gaze-overlay"></div>

    <script>
        const { ipcRenderer } = require('electron');

        let liveMetrics = {
            totalKeyPresses: 0,
            totalBackspaces: 0,
            totalBatches: 0,
            lastBatch: null,
            gazePoints: [],
            gazeAnalytics: {
                fixations: [],
                saccades: [],
                readingPatterns: [],
                rereadingEvents: [],
                regionFocusDurations: {}
            }
        };

        let gazeTracking = false;
        let gazeAnalysisInterval = null;

        // Gaze Analytics Configuration
        const GAZE_CONFIG = {
            fixationRadiusPx: 50,           // Maximum distance for points to be in same fixation
            fixationMinDurationMs: 100,     // Minimum time to be considered a fixation
            saccadeMinDistancePx: 100,      // Minimum distance to be considered a saccade
            readingLineHeightPx: 40,        // Vertical tolerance for same reading line
            readingMinHorizontalDistancePx: 50, // Minimum horizontal movement for reading
            rereadingVerticalTolerancePx: 50,   // Vertical tolerance for detecting re-reading
            screenRegionRows: 4,            // Divide screen into grid (rows)
            screenRegionCols: 4,            // Divide screen into grid (cols)
            analysisIntervalMs: 1000        // How often to analyze gaze data
        };

        // Initialize
        async function init() {
            console.log('[Dashboard] Initializing...');

            // Get config
            const config = await ipcRenderer.invoke('get-config');
            console.log('[Dashboard] Config loaded:', config);

            // Update tracking status
            updateTrackingStatus();

            // Listen for batch updates
            ipcRenderer.on('batch-sent', (event, metrics) => {
                console.log('[Dashboard] Batch received:', metrics);
                handleBatchSent(metrics);
            });

            // Listen for tracking status changes
            ipcRenderer.on('tracking-status-changed', (event, isTracking) => {
                updateTrackingStatus();
            });

            console.log('[Dashboard] Ready!');
        }

        function handleBatchSent(metrics) {
            liveMetrics.lastBatch = metrics;
            liveMetrics.totalBatches++;
            liveMetrics.totalKeyPresses += metrics.keyboard.keyPressCount;
            liveMetrics.totalBackspaces += metrics.keyboard.backspaceCount;

            updateLiveMetrics();
        }

        function updateLiveMetrics() {
            const batch = liveMetrics.lastBatch;
            if (!batch) return;

            // Calculate duration
            const start = new Date(batch.startedAt);
            const end = new Date(batch.endedAt);
            const durationSec = (end - start) / 1000;

            // Typing speed (keys per second)
            const typingSpeed = durationSec > 0 ? (batch.keyboard.keyPressCount / durationSec).toFixed(2) : 0;
            document.getElementById('metric-typing-speed').innerHTML = `${typingSpeed} <small>keys/s</small>`;

            // Mouse speed
            const mouseSpeed = batch.mouse.meanSpeedPxPerSec.toFixed(0);
            document.getElementById('metric-mouse-speed').innerHTML = `${mouseSpeed} <small>px/s</small>`;

            // Error rate
            const errorRate = batch.keyboard.keyPressCount > 0
                ? ((batch.keyboard.backspaceCount / batch.keyboard.keyPressCount) * 100).toFixed(1)
                : 0;
            document.getElementById('metric-error-rate').innerHTML = `${errorRate}%`;

            // Batches
            document.getElementById('metric-batches').textContent = liveMetrics.totalBatches;

            // Batch data display removed - not needed
        }

        async function updateTrackingStatus() {
            const isTracking = await ipcRenderer.invoke('get-tracking-status');
            const statusBadge = document.getElementById('tracking-status');

            if (isTracking) {
                statusBadge.textContent = 'Tracking Active ‚úì';
                statusBadge.className = 'status-badge active';
            } else {
                statusBadge.textContent = 'Tracking Paused';
                statusBadge.className = 'status-badge inactive';
            }
        }

        // ==========================================
        // GAZE ANALYTICS ALGORITHMS
        // ==========================================

        /**
         * Calculate Euclidean distance between two points
         */
        function calculateDistance(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Detect fixations: periods where gaze stays within a small radius
         * Returns array of fixation objects with centroid, duration, and gaze points
         */
        function detectFixations(gazePoints) {
            if (gazePoints.length === 0) return [];

            const fixations = [];
            let currentFixation = {
                points: [gazePoints[0]],
                startTime: gazePoints[0].timestamp,
                endTime: gazePoints[0].timestamp
            };

            for (let i = 1; i < gazePoints.length; i++) {
                const point = gazePoints[i];

                // Calculate centroid of current fixation
                const centroid = {
                    x: currentFixation.points.reduce((sum, p) => sum + p.x, 0) / currentFixation.points.length,
                    y: currentFixation.points.reduce((sum, p) => sum + p.y, 0) / currentFixation.points.length
                };

                // Check if point is within fixation radius
                const distance = calculateDistance(centroid, point);

                if (distance <= GAZE_CONFIG.fixationRadiusPx) {
                    // Part of current fixation
                    currentFixation.points.push(point);
                    currentFixation.endTime = point.timestamp;
                } else {
                    // End current fixation and start new one
                    const duration = currentFixation.endTime - currentFixation.startTime;

                    if (duration >= GAZE_CONFIG.fixationMinDurationMs) {
                        fixations.push({
                            centroid: centroid,
                            startTime: currentFixation.startTime,
                            endTime: currentFixation.endTime,
                            durationMs: duration,
                            pointCount: currentFixation.points.length
                        });
                    }

                    // Start new fixation
                    currentFixation = {
                        points: [point],
                        startTime: point.timestamp,
                        endTime: point.timestamp
                    };
                }
            }

            // Handle last fixation
            const duration = currentFixation.endTime - currentFixation.startTime;
            if (duration >= GAZE_CONFIG.fixationMinDurationMs) {
                const centroid = {
                    x: currentFixation.points.reduce((sum, p) => sum + p.x, 0) / currentFixation.points.length,
                    y: currentFixation.points.reduce((sum, p) => sum + p.y, 0) / currentFixation.points.length
                };
                fixations.push({
                    centroid: centroid,
                    startTime: currentFixation.startTime,
                    endTime: currentFixation.endTime,
                    durationMs: duration,
                    pointCount: currentFixation.points.length
                });
            }

            return fixations;
        }

        /**
         * Detect saccades: rapid eye movements between fixations
         * Returns array of saccade objects with velocity, amplitude, and direction
         */
        function detectSaccades(fixations) {
            if (fixations.length < 2) return [];

            const saccades = [];

            for (let i = 1; i < fixations.length; i++) {
                const fromFixation = fixations[i - 1];
                const toFixation = fixations[i];

                const distance = calculateDistance(fromFixation.centroid, toFixation.centroid);

                // Only consider movements above threshold
                if (distance >= GAZE_CONFIG.saccadeMinDistancePx) {
                    const timeDelta = toFixation.startTime - fromFixation.endTime;
                    const velocity = timeDelta > 0 ? distance / timeDelta : 0; // px/ms

                    // Calculate direction (angle in degrees)
                    const dx = toFixation.centroid.x - fromFixation.centroid.x;
                    const dy = toFixation.centroid.y - fromFixation.centroid.y;
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);

                    saccades.push({
                        fromFixation: i - 1,
                        toFixation: i,
                        startPoint: fromFixation.centroid,
                        endPoint: toFixation.centroid,
                        amplitudePx: distance,
                        velocityPxPerMs: velocity,
                        durationMs: timeDelta,
                        angleDegrees: angle
                    });
                }
            }

            return saccades;
        }

        /**
         * Detect reading patterns: left-to-right horizontal movements
         * Returns array of reading sequences
         */
        function detectReadingPatterns(fixations) {
            if (fixations.length < 3) return [];

            const readingSequences = [];
            let currentSequence = [];

            for (let i = 1; i < fixations.length; i++) {
                const prevFixation = fixations[i - 1];
                const currFixation = fixations[i];

                const dx = currFixation.centroid.x - prevFixation.centroid.x;
                const dy = Math.abs(currFixation.centroid.y - prevFixation.centroid.y);

                // Check if movement is primarily horizontal (left-to-right) on same line
                const isHorizontalMovement = dx > GAZE_CONFIG.readingMinHorizontalDistancePx;
                const isSameLine = dy < GAZE_CONFIG.readingLineHeightPx;

                if (isHorizontalMovement && isSameLine) {
                    // Part of reading pattern
                    if (currentSequence.length === 0) {
                        currentSequence.push(i - 1); // Add previous fixation
                    }
                    currentSequence.push(i);
                } else {
                    // End current reading sequence
                    if (currentSequence.length >= 3) {
                        const startFixation = fixations[currentSequence[0]];
                        const endFixation = fixations[currentSequence[currentSequence.length - 1]];

                        readingSequences.push({
                            fixationIndices: currentSequence,
                            startTime: startFixation.startTime,
                            endTime: endFixation.endTime,
                            durationMs: endFixation.endTime - startFixation.startTime,
                            fixationCount: currentSequence.length,
                            averageY: currentSequence.reduce((sum, idx) => sum + fixations[idx].centroid.y, 0) / currentSequence.length
                        });
                    }
                    currentSequence = [];
                }
            }

            // Handle last sequence
            if (currentSequence.length >= 3) {
                const startFixation = fixations[currentSequence[0]];
                const endFixation = fixations[currentSequence[currentSequence.length - 1]];

                readingSequences.push({
                    fixationIndices: currentSequence,
                    startTime: startFixation.startTime,
                    endTime: endFixation.endTime,
                    durationMs: endFixation.endTime - startFixation.startTime,
                    fixationCount: currentSequence.length,
                    averageY: currentSequence.reduce((sum, idx) => sum + fixations[idx].centroid.y, 0) / currentSequence.length
                });
            }

            return readingSequences;
        }

        /**
         * Detect re-reading: returning to previously viewed areas
         * Returns array of re-reading events
         */
        function detectRereading(fixations, readingPatterns) {
            if (readingPatterns.length < 2) return [];

            const rereadingEvents = [];

            for (let i = 1; i < readingPatterns.length; i++) {
                const currentPattern = readingPatterns[i];

                // Check if current pattern overlaps vertically with previous patterns
                for (let j = 0; j < i; j++) {
                    const previousPattern = readingPatterns[j];

                    const verticalDistance = Math.abs(currentPattern.averageY - previousPattern.averageY);

                    if (verticalDistance < GAZE_CONFIG.rereadingVerticalTolerancePx) {
                        rereadingEvents.push({
                            currentPatternIndex: i,
                            previousPatternIndex: j,
                            verticalDistancePx: verticalDistance,
                            timeBetweenMs: currentPattern.startTime - previousPattern.endTime,
                            currentY: currentPattern.averageY,
                            previousY: previousPattern.averageY
                        });
                    }
                }
            }

            return rereadingEvents;
        }

        /**
         * Calculate focus duration per screen region
         * Divides screen into grid and calculates total fixation time per region
         */
        function calculateRegionFocusDurations(fixations) {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const regionWidth = screenWidth / GAZE_CONFIG.screenRegionCols;
            const regionHeight = screenHeight / GAZE_CONFIG.screenRegionRows;

            const regionDurations = {};

            for (const fixation of fixations) {
                const row = Math.floor(fixation.centroid.y / regionHeight);
                const col = Math.floor(fixation.centroid.x / regionWidth);

                // Ensure within bounds
                const boundedRow = Math.max(0, Math.min(row, GAZE_CONFIG.screenRegionRows - 1));
                const boundedCol = Math.max(0, Math.min(col, GAZE_CONFIG.screenRegionCols - 1));

                const regionKey = `R${boundedRow}C${boundedCol}`;

                if (!regionDurations[regionKey]) {
                    regionDurations[regionKey] = {
                        row: boundedRow,
                        col: boundedCol,
                        totalDurationMs: 0,
                        fixationCount: 0
                    };
                }

                regionDurations[regionKey].totalDurationMs += fixation.durationMs;
                regionDurations[regionKey].fixationCount += 1;
            }

            return regionDurations;
        }

        /**
         * Compute comprehensive gaze analytics
         */
        function computeGazeAnalytics() {
            if (liveMetrics.gazePoints.length === 0) return null;

            console.log(`[GazeAnalytics] Analyzing ${liveMetrics.gazePoints.length} gaze points...`);

            // Detect fixations
            const fixations = detectFixations(liveMetrics.gazePoints);
            console.log(`[GazeAnalytics] Detected ${fixations.length} fixations`);

            // Detect saccades
            const saccades = detectSaccades(fixations);
            console.log(`[GazeAnalytics] Detected ${saccades.length} saccades`);

            // Detect reading patterns
            const readingPatterns = detectReadingPatterns(fixations);
            console.log(`[GazeAnalytics] Detected ${readingPatterns.length} reading patterns`);

            // Detect re-reading
            const rereadingEvents = detectRereading(fixations, readingPatterns);
            console.log(`[GazeAnalytics] Detected ${rereadingEvents.length} re-reading events`);

            // Calculate region focus durations
            const regionFocusDurations = calculateRegionFocusDurations(fixations);
            console.log(`[GazeAnalytics] Calculated focus durations for ${Object.keys(regionFocusDurations).length} regions`);

            // Store in analytics
            liveMetrics.gazeAnalytics = {
                fixations,
                saccades,
                readingPatterns,
                rereadingEvents,
                regionFocusDurations
            };

            // Compute summary statistics
            const totalFixationTime = fixations.reduce((sum, f) => sum + f.durationMs, 0);
            const avgFixationDuration = fixations.length > 0 ? totalFixationTime / fixations.length : 0;
            const avgSaccadeAmplitude = saccades.length > 0
                ? saccades.reduce((sum, s) => sum + s.amplitudePx, 0) / saccades.length
                : 0;
            const avgSaccadeVelocity = saccades.length > 0
                ? saccades.reduce((sum, s) => sum + s.velocityPxPerMs, 0) / saccades.length
                : 0;

            return {
                rawGazePointCount: liveMetrics.gazePoints.length,
                fixationCount: fixations.length,
                totalFixationTimeMs: totalFixationTime,
                avgFixationDurationMs: avgFixationDuration,
                saccadeCount: saccades.length,
                avgSaccadeAmplitudePx: avgSaccadeAmplitude,
                avgSaccadeVelocityPxPerMs: avgSaccadeVelocity,
                readingPatternCount: readingPatterns.length,
                rereadingEventCount: rereadingEvents.length,
                fixations: fixations,
                saccades: saccades,
                readingPatterns: readingPatterns,
                rereadingEvents: rereadingEvents,
                regionFocusDurations: regionFocusDurations
            };
        }

        /**
         * Periodically analyze gaze data and send with batch
         */
        function startGazeAnalysis() {
            gazeAnalysisInterval = setInterval(() => {
                const gazeAnalytics = computeGazeAnalytics();

                if (gazeAnalytics) {
                    console.log('[GazeAnalytics] Summary:', {
                        fixations: gazeAnalytics.fixationCount,
                        saccades: gazeAnalytics.saccadeCount,
                        readingPatterns: gazeAnalytics.readingPatternCount,
                        rereading: gazeAnalytics.rereadingEventCount
                    });

                    // Send gaze analytics to main process for inclusion in next batch
                    ipcRenderer.send('gaze-analytics', gazeAnalytics);
                }
            }, GAZE_CONFIG.analysisIntervalMs);
        }

        function stopGazeAnalysis() {
            if (gazeAnalysisInterval) {
                clearInterval(gazeAnalysisInterval);
                gazeAnalysisInterval = null;
            }
        }

        // ==========================================
        // EYE TRACKING CONTROLS
        // ==========================================

        // Eye Tracking Calibration
        document.getElementById('calibrate-eyes').addEventListener('click', async () => {
            if (!gazeTracking) {
                alert('Please start eye tracking first!');
                return;
            }

            const statusEl = document.getElementById('calibration-status');
            statusEl.textContent = 'Starting calibration... Look at each dot and click it!';

            // Clear existing calibration data
            webgazer.clearData();

            // 9-point calibration grid
            const points = [
                { x: 0.1, y: 0.1 },  // Top-left
                { x: 0.5, y: 0.1 },  // Top-center
                { x: 0.9, y: 0.1 },  // Top-right
                { x: 0.1, y: 0.5 },  // Middle-left
                { x: 0.5, y: 0.5 },  // Center
                { x: 0.9, y: 0.5 },  // Middle-right
                { x: 0.1, y: 0.9 },  // Bottom-left
                { x: 0.5, y: 0.9 },  // Bottom-center
                { x: 0.9, y: 0.9 }   // Bottom-right
            ];

            for (let i = 0; i < points.length; i++) {
                const screenX = window.innerWidth * points[i].x;
                const screenY = window.innerHeight * points[i].y;

                statusEl.textContent = `Point ${i + 1}/9 - Stare at the pulsing dot and click it 3 times`;

                // Create calibration point
                const point = document.createElement('div');
                point.style.position = 'fixed';
                point.style.width = '40px';
                point.style.height = '40px';
                point.style.borderRadius = '50%';
                point.style.background = 'radial-gradient(circle, #ff0000, #cc0000)';
                point.style.left = screenX + 'px';
                point.style.top = screenY + 'px';
                point.style.transform = 'translate(-50%, -50%)';
                point.style.cursor = 'pointer';
                point.style.zIndex = '10000';
                point.style.boxShadow = '0 0 30px rgba(255, 0, 0, 1)';
                point.style.animation = 'pulse 1s infinite';
                document.body.appendChild(point);

                // Add pulsing animation if not exists
                if (!document.getElementById('calibration-style')) {
                    const style = document.createElement('style');
                    style.id = 'calibration-style';
                    style.textContent = `
                        @keyframes pulse {
                            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                // Wait for 3 clicks at this position
                await new Promise(resolve => {
                    let clickCount = 0;
                    const clickHandler = async (e) => {
                        clickCount++;
                        point.style.background = `radial-gradient(circle, #00ff00, #00cc00)`;

                        // Give WebGazer time to record the click
                        await new Promise(r => setTimeout(r, 300));

                        if (clickCount >= 3) {
                            point.removeEventListener('click', clickHandler);
                            resolve();
                        } else {
                            point.style.background = `radial-gradient(circle, #ff0000, #cc0000)`;
                        }
                    };
                    point.addEventListener('click', clickHandler);
                });

                // Remove point
                document.body.removeChild(point);
                await new Promise(resolve => setTimeout(resolve, 800));
            }

            statusEl.textContent = '‚úì Calibration complete! Eye tracking is now trained for your eyes.';
            setTimeout(() => {
                statusEl.textContent = '';
            }, 5000);
        });

        // Eye Tracking with WebGazer
        document.getElementById('start-gaze').addEventListener('click', async () => {
            try {
                console.log('[WebGazer] Starting...');

                await webgazer.setRegression('ridge')
                    .setTracker('TFFacemesh')
                    .setGazeListener((data, timestamp) => {
                        if (data == null) return;

                        // Update gaze dot
                        updateGazeDot(data.x, data.y);

                        // Store gaze point
                        liveMetrics.gazePoints.push({
                            x: data.x,
                            y: data.y,
                            timestamp: timestamp
                        });
                    })
                    .begin();

                webgazer.showVideoPreview(true)
                    .showPredictionPoints(true)
                    .applyKalmanFilter(true);

                document.getElementById('start-gaze').style.display = 'none';
                document.getElementById('stop-gaze').style.display = 'inline-block';

                gazeTracking = true;

                // Start periodic gaze analysis
                startGazeAnalysis();

                console.log('[WebGazer] Started successfully!');
            } catch (error) {
                console.error('[WebGazer] Error:', error);
                alert('Failed to start eye tracking: ' + error.message);
            }
        });

        document.getElementById('stop-gaze').addEventListener('click', () => {
            webgazer.end();
            document.getElementById('start-gaze').style.display = 'inline-block';
            document.getElementById('stop-gaze').style.display = 'none';

            gazeTracking = false;
            stopGazeAnalysis();

            console.log('[WebGazer] Stopped');
        });

        function updateGazeDot(x, y) {
            let dot = document.querySelector('.gaze-dot');
            if (!dot) {
                dot = document.createElement('div');
                dot.className = 'gaze-dot';
                document.getElementById('gaze-overlay').appendChild(dot);
            }
            dot.style.left = x + 'px';
            dot.style.top = y + 'px';
        }

        // ==========================================
        // NAVIGATION TRACKING (Google in Google detection)
        // ==========================================

        let searchHistory = [];
        let lastSearchQuery = '';

        // Track URL changes and search queries
        setInterval(() => {
            const currentUrl = window.location.href;
            let searchQuery = '';

            // Check if on Google search
            if (currentUrl.includes('google.com')) {
                // Extract search query from URL
                const urlParams = new URLSearchParams(window.location.search);
                searchQuery = urlParams.get('q') || '';

                if (searchQuery && searchQuery !== lastSearchQuery) {
                    lastSearchQuery = searchQuery;

                    // Add to history
                    searchHistory.push({
                        query: searchQuery.toLowerCase(),
                        timestamp: Date.now()
                    });

                    // Keep only last 10 searches
                    if (searchHistory.length > 10) {
                        searchHistory.shift();
                    }

                    // Check for repeated searches (same query within 5 minutes)
                    const recentSearches = searchHistory.filter(s =>
                        Date.now() - s.timestamp < 5 * 60 * 1000
                    );
                    const queryCounts = {};
                    recentSearches.forEach(s => {
                        queryCounts[s.query] = (queryCounts[s.query] || 0) + 1;
                    });

                    // If searched same thing 3+ times, it's confusion
                    Object.entries(queryCounts).forEach(([query, count]) => {
                        if (count >= 3) {
                            console.log(`[Navigation Alert] Searched "${query}" ${count} times - possible confusion`);
                            ipcRenderer.send('navigation-update', {
                                url: currentUrl,
                                searchQuery: query,
                                repeatCount: count,
                                type: 'REPEATED_SEARCH'
                            });
                        }
                    });

                    // Send for Google in Google detection
                    ipcRenderer.send('navigation-update', {
                        url: currentUrl,
                        searchQuery: searchQuery
                    });
                }
            }
        }, 2000); // Check every 2 seconds

        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
